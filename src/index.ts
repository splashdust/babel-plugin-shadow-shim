import template from "@babel/template";
import generate from "@babel/generator";
import { Identifier, MemberExpression, Program, Statement } from "@babel/types";
import { NodePath, Visitor } from "@babel/traverse";

// Name of the wrapper function generated by the plugin.
const WRAPPER_FUNC = "__SDOMRef__";

// Supported DOM methods that we'll deal with in the wrapper function
const supportedDomMethods = [
  "getElementById",
  "querySelectorAll",
  "querySelector",
];

// These methods are not supported on DocumentFragment, so they needs
// to be transformed instead of wrapped.
const unsupportedDomMethods = [
  "getElementsByClassName",
  "getElementsByTagName",
];

// TODO:
// Consider actions for
// getElementByName
// elementsFromPoint
// elementFromPoint
// addEventListener

// This Visitor handles supported DOM methods by wrapping the original DOM ref (eg. 'document')
// in our wrapper function.
const supportedDomMethodVisitor: Visitor = {
  Identifier: wrapDomRefAtPath,
  MemberExpression: wrapDomRefAtPath
};
function wrapDomRefAtPath(
  path: NodePath<Identifier | MemberExpression>,
  state: any
) {
  const ogDomRef = generate(path.node);
  const appIdentifier = state.opts?.appIdentifier ?? "";
  path.replaceWithSourceString(
    `${WRAPPER_FUNC}${appIdentifier}(${ogDomRef.code}, '${state.domMethodName}')`
  );
  process.stdout.write(` Patched!\n`);
  path.stop();
}

function hasIgnoreComment(path: NodePath) {
  return path
    .findParent((path) => path.node.leadingComments !== undefined)
    ?.node.leadingComments.some(
      (comment) => comment.value.trim() === "shadow-shim-ignore"
    );
}

module.exports = function () {
  return {
    visitor: {
      Identifier(path: NodePath<Identifier>, state: any) {
        const name = path.node.name;

        if (supportedDomMethods.includes(name)) {
          if (hasIgnoreComment(path)) return;
          process.stdout.write(`--> Found ${name}...`);
          path.parentPath.traverse(supportedDomMethodVisitor as Visitor, {
            domMethodName: name,
            opts: state.opts,
          });
        }

        if (unsupportedDomMethods.includes(name)) {
          if (hasIgnoreComment(path)) return;
          console.warn(
            path.buildCodeFrameError(
              `WARNING: '${name}' may not work with shadow DOM. Use 'querySelectorAll' instead.`
            )
          );
        }
      },
      Program(path: NodePath<Program>, state: any) {
        // This function gets a refernce from which a DOM method (querySelector, getElementById, etc) is supposed to be called.
        // We'll investigate what the object is and take an appropriate action.
        // The DOM method will get called on the reference that is returned from this function.
        const appIdentifier = state.opts?.appIdentifier ?? "";
        const rootSel = state.opts?.shadowRootSelector;
        const func_shadowShimWrapper = template(
          `
        function ${WRAPPER_FUNC}${appIdentifier}(ogDOMRef, methodName) {
          // shadow-shim-ignore
          const shadowRoot = document.querySelector('${rootSel}').shadowRoot ?? document

          if (methodName === 'getElementById' || ogDOMRef === document) {
            return shadowRoot
          }

          // If we're not doing getElementById and the original ref is not 'document',
          // then we'll return the original ref here.
          return ogDOMRef
        }
        `,
          { preserveComments: true }
        );

        // Inject the wrapper function at the end of the document.
        path.node.body.push(func_shadowShimWrapper() as Statement);
      },
    },
    post() {
      console.log();
      console.log("Done!");
      console.log();
    },
  };
};
